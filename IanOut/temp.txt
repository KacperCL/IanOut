//-----------------------------------------------------------------------------
// Name: InitApp()
// Desc: Do work required for every instance of the application:
//          Create the window, initialize data
//-----------------------------------------------------------------------------

int GetFRMData(char dat)
{
	FILE		*stream;
	char		buf[74];
	DWORD		i;
	DWORD		ki;

	
	if( (stream = fopen( "test.frm", "r" )) != NULL )
   {
		if (dat=='W') {
			fread(&buf, 62, 1, stream);
		}
		else 
		{
			fread(&buf, 64, 1, stream);
		}
	  // ki = 0;
	  i = fgetc( stream);
	  ki=i*256;
	  i = fgetc( stream);
	  ki+=i;
	  fclose( stream );
   }
   
   return i;
}

int LoadFRM(HWND hWnd, LPVOID LoadInto, int x, int y, int pitch)
{
	char		buf[100];
	LPSTR		PointTo;
	int			i;
	int			stream;

	PointTo = (LPSTR)LoadInto;
	if( (stream = _open( "test.frm",_O_BINARY)) != -1 )
   {
      _read(stream, &buf, 74);

  	  for (i=0; i<y; i++)
	  {
		_read(stream, PointTo+(i*pitch), x);
	  }
      _close( stream );
   }
   else
      InitFail(hWnd, DD_OK, "Fajl betoltese sikertelen");

   return 0;
	
}

	RECT		rcRect;
	HRESULT		hRet;

	rcRect.left   = FontMap[(c-32)]+1;
	rcRect.top    = (co*12)+1;
	rcRect.right  = FontMap[(c-31)]+1;
	rcRect.bottom = (co*12)+12;


	while (TRUE)
        {
            hRet = g_pDDSBack->BltFast(x, y, g_pDDSOne,
                         &rcRect, DDBLTFAST_SRCCOLORKEY);
            if (hRet == DD_OK)
                break;
            if (hRet == DDERR_SURFACELOST)
            {
                hRet = RestoreAll();
                if (hRet != DD_OK)
                    return;
            }
            if (hRet != DDERR_WASSTILLDRAWING)
                return;
        }


void IanOutText(int x, int y, int co, CString str)
{
	int		i;
	int		jelenx = 0;
	int		sor = 0;
	int		length = str.GetLength();
	for (i=0 ; i<length; i++)
	{
		if ((str[i]!='\n') && 
		    (str[i]!='á') && 
			(str[i]!='é') &&
			(str[i]!='í') &&
			(str[i]!='ó') &&
			(str[i]!='ú') &&
			(str[i]!='ö') &&
			(str[i]!='ü'))
			
		{ 
			DrawChar(x+jelenx,y+sor,co,str[i]);
			jelenx += FontMap[str[i]-31]-FontMap[str[i]-32];
		} else
		if (str[i]=='\n')
		{
			sor += 12;
			jelenx=0;
		} else
	    if (str[i]=='á')
		{
	        DrawChar(x+jelenx+2,y+sor-6,co,',');
			DrawChar(x+jelenx,y+sor,co,'a');
			jelenx += FontMap['a'-31]-FontMap['a'-32];
		} else
		if (str[i]=='é')
		{
	        DrawChar(x+jelenx+2,y+sor-6,co,',');
			DrawChar(x+jelenx,y+sor,co,'e');
			jelenx += FontMap['e'-31]-FontMap['e'-32];
		} else
		if (str[i]=='í')
		{
	        DrawChar(x+jelenx,y+sor-6,co,',');
			DrawChar(x+jelenx,y+sor,co,'i');
			jelenx += FontMap['i'-31]-FontMap['i'-32];
		}else
		if (str[i]=='ó')
		{
	        DrawChar(x+jelenx+2,y+sor-6,co,',');
			DrawChar(x+jelenx,y+sor,co,'o');
			jelenx += FontMap['o'-31]-FontMap['o'-32];
		}else
		if (str[i]=='ú')
		{
	        DrawChar(x+jelenx+2,y+sor-6,co,',');
			DrawChar(x+jelenx,y+sor,co,'u');
			jelenx += FontMap['u'-31]-FontMap['u'-32];
		}else
		if (str[i]=='ö')
		{
	        DrawChar(x+jelenx,y+sor-1,co,'"');
			DrawChar(x+jelenx,y+sor,co,'o');
			jelenx += FontMap['o'-31]-FontMap['o'-32];
		}else
		if (str[i]=='ü')
		{
	        DrawChar(x+jelenx,y+sor-1,co,'"');
			DrawChar(x+jelenx,y+sor,co,'u');
			jelenx += FontMap['u'-31]-FontMap['u'-32];
		}
		
	}
}

//-----------------------------------------------------------------------------
// Name: RestoreAll()
// Desc: Restore all lost objects
//-----------------------------------------------------------------------------


HRESULT InitDirectInput( HWND hDlg,HINSTANCE g_hInst )
{
    HRESULT hr;

    // Register with the DirectInput subsystem and get a pointer
    // to a IDirectInput interface we can use.
    hr = DirectInputCreate( g_hInst, DIRECTINPUT_VERSION, &g_pDI, NULL );
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"DirectInputCreate Failed");

    // Obtain an interface to the system mouse device.
    hr = g_pDI->CreateDevice( GUID_SysMouse, &g_pMouse, NULL );
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"CreateDevice (mouse) failed");

    /*hr = g_pDI->CreateDevice( GUID_SysKeyboard, &g_pKeyb, NULL );
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"CreateDevice (keyboard) failed");;*/

    // Set the data format to "mouse format" - a predefined data format 
    //
    // A data format specifies which controls on a device we
    // are interested in, and how they should be reported.
    //
    // This tells DirectInput that we will be passing a
    // DIMOUSESTATE structure to IDirectInputDevice::GetDeviceState.
    hr = g_pMouse->SetDataFormat( &c_dfDIMouse );
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"SetDataFormat (mouse) failed");

	/*hr = g_pKeyb->SetDataFormat( &c_dfDIKeyboard );
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"SetDataFormat (keyb) failed");;*/

    // Set the cooperativity level to let DirectInput know how
    // this device should interact with the system and with other
    // DirectInput applications.
    hr = g_pMouse->SetCooperativeLevel( hDlg, 
                                        DISCL_EXCLUSIVE | DISCL_FOREGROUND);
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"SetCooperativeLevel (mouse) failed");

	/*hr = g_pKeyb->SetCooperativeLevel( hDlg, 
                                        DISCL_EXCLUSIVE | DISCL_FOREGROUND);
    if ( FAILED(hr) ) 
        return InitFail(hDlg,hr,"SetCooperativeLevel (keyb) failed");*/

    return S_OK;
}




//-----------------------------------------------------------------------------
// Function: SetAcquire
//
// Description: 
//      Acquire or unacquire the mouse, depending on if the app is active
//       Input device must be acquired before the GetDeviceState is called
//
//-----------------------------------------------------------------------------
HRESULT SetAcquire( )
{

    // nothing to do if g_pMouse is NULL
    if (NULL == g_pMouse)
        return S_FALSE;

    if (g_bActive) 
    {
        // acquire the input device 
        g_pMouse->Acquire();
        //g_pKeyb->Acquire();
    } 
    else 
    {

        // unacquire the input device 
        g_pMouse->Unacquire();
        //g_pKeyb->Unacquire();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Function: UpdateInputState
//
// Description: 
//      Get the input device's state and display it.
//
//-----------------------------------------------------------------------------
HRESULT UpdateInputState( )
{
   
    if (NULL != g_pMouse) 
    {
        HRESULT hr;

        hr = DIERR_INPUTLOST;

        // if input is lost then acquire and keep trying 
        while ( DIERR_INPUTLOST == hr ) 
        {
            // get the input's device state, and put the state in dims
            hr = g_pMouse->GetDeviceState( sizeof(DIMOUSESTATE), &dims );

            if ( hr == DIERR_INPUTLOST )
            {
                // DirectInput is telling us that the input stream has
                // been interrupted.  We aren't tracking any state
                // between polls, so we don't have any special reset
                // that needs to be done.  We just re-acquire and
                // try again.
                hr = g_pMouse->Acquire();
                if ( FAILED(hr) )  
                    return hr;
            }
        }

        if ( FAILED(hr) )  
            return hr;
   

	/*int i;

	for (i=0; i<255; i++)
	{
		olddim[i] = keybdim[i];	
	}
    hr = g_pKeyb->GetDeviceState(sizeof(keybdim),(LPVOID)&keybdim); 
    if FAILED(hr) 
    { 
         return hr; 
    } */
 

        // The dims structure now has the state of the mouse, so 
        // display mouse coordinates (x, y, z) and buttons.
        /*wsprintf( szNewText, "(%d, %d, %d) %c %c %c %c",
                     dims.lX, dims.lY, dims.lZ,
                     (dims.rgbButtons[0] & 0x80) ? '0' : ' ',
                     (dims.rgbButtons[1] & 0x80) ? '1' : ' ',
                     (dims.rgbButtons[2] & 0x80) ? '2' : ' ',
                     (dims.rgbButtons[3] & 0x80) ? '3' : ' ');
*/
        // if anything changed then repaint - avoid flicker

    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Function: FreeDirectInput
//
// Description: 
//      Initialize the DirectInput variables.
//
//-----------------------------------------------------------------------------
HRESULT FreeDirectInput()
{
    // Unacquire and release any DirectInputDevice objects.
    if (NULL != g_pMouse) 
    {
        // Unacquire the device one last time just in case 
        // the app tried to exit while the device is still acquired.
        g_pMouse->Unacquire();

        g_pMouse->Release();
        g_pMouse = NULL;
    }
    
	/*if (NULL != g_pKeyb)
	{
		g_pKeyb->Unacquire();

        g_pKeyb->Release();
        g_pKeyb = NULL;
	}*/
    // Release any DirectInput objects.
    if (NULL != g_pDI) 
    {
        g_pDI->Release();
        g_pDI = NULL;
    }

    return S_OK;
}

pe2[i].peBlue = Frame;  
		pe2[i].peGreen = Frame;
		pe2[i].peRed = Frame;
		if (pe2[i].peBlue>(int)(pe[i].peBlue*gamma)) pe2[i].peBlue = (int)(pe[i].peBlue*gamma);
		if (pe2[i].peRed>(int)(pe[i].peRed*gamma)) pe2[i].peRed = (int)(pe[i].peRed*gamma);
		if (pe2[i].peGreen>(int)(pe[i].peGreen*gamma)) pe2[i].peGreen = (int)(pe[i].peGreen*gamma);
		if (pe2[i].peBlue>255) pe2[i].peBlue=255;
		if (pe2[i].peRed>255) pe2[i].peRed=255;
		if (pe2[i].peGreen>255) pe2[i].peGreen=255;



//DisplayNum(0,70,2,-TerX+MousX,4);
	//DisplayNum(70,70,2,-TerY+MousY,4);

	for (x=0; x<160; x++) {
		for (y=0; y<150; y++) {
			if ((y%2==x%2) && (Ian->Table[x][y] != 111))
				DisplayNum(TerX+(x+226)*14, TerY+y*12, 2, Ian->Table[x][y],2);

		}
	}


	if (i<100)
	{
		PosIt[0][0]=1;
		PosIt[0][1]=i;
		PosIt[1][0]=tx;
		PosIt[1][1]=ty;

		Mehet = TRUE;
		while (Mehet)
		{
			i--;
			if (i<1) {Mehet=FALSE;i=1;}
			for (ix=2; ix<170; ix++)
				for (iy=1; iy<150; iy++)
				{
				if (Table[ix][iy] == i)
				{
					if ((ix+2 == PosIt[i-1][0]) &&
						(iy   == PosIt[i-1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix-2 == PosIt[i-1][0]) &&
						(iy   == PosIt[i-1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix+1 == PosIt[i-1][0]) &&
						(iy+1 == PosIt[i-1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix+1 == PosIt[i-1][0]) &&
						(iy-1 == PosIt[i-1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix-1 == PosIt[i-1][0]) &&
						(iy+1 == PosIt[i-1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix-1 == PosIt[i-1][0]) &&
						(iy-1 == PosIt[i-1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
				}
				}
			}

	} else
	{
		PosIt[0][0]=-1;
		PosIt[0][1]=-1;
	}



	i--;
			if (i<1) {Mehet=FALSE;i=1;}
			for (ix=2; ix<163; ix++)
				for (iy=1; iy<143; iy++)
				{
				if (Table[ix][iy] == i)
				{
					if ((ix+2 == PosIt[i+1][0]) &&
						(iy   == PosIt[i+1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix-2 == PosIt[i+1][0]) &&
						(iy   == PosIt[i+1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix+1 == PosIt[i+1][0]) &&
						(iy+1 == PosIt[i+1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix+1 == PosIt[i+1][0]) &&
						(iy-1 == PosIt[i+1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix-1 == PosIt[i+1][0]) &&
						(iy+1 == PosIt[i+1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
					if ((ix-1 == PosIt[i+1][0]) &&
						(iy-1 == PosIt[i+1][1])) {PosIt[i][0]=ix;PosIt[i][1]=iy;}
				}
				}


extern "C"
HRESULT BlitTo(LPDIRECTDRAWSURFACE7 Blit,int Sx1, int Sy1, int Sx2, int Sy2, int Dx, int Dy, DWORD flags, LPDIRECTDRAWSURFACE7 surf)
{
    DDBLTFX                     ddbltfx;
    RECT                        rcRect;
	RECT						rcDest;
	HRESULT                     hRet;
	int							iw1;
	int							iw2;

	hRet = DD_OK;
    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    ddbltfx.dwFillColor = 0;

    rcRect.left = Sx1;
    rcRect.top = Sy1;
    rcRect.right = Sx2;
    rcRect.bottom = Sy2;

    iw1 = Sx2-Sx1;
	iw2 = Sy2-Sy1;

	if (!((Dx>640) || (Dy>480) || (Dx+iw1<0) || (Dy+iw2<0))) {

	rcDest.left = Dx;
    rcDest.top = Dy;
    rcDest.right = Dx+iw1;
    rcDest.bottom = Dy+iw2;

    while (TRUE)
    {
        hRet = Blit->Blt(&rcDest, surf, &rcRect, flags, &ddbltfx);

        if (hRet == DD_OK)
            break;
        if (hRet == DDERR_SURFACELOST)
        {
           /* hRet = RestoreAll();
            if (hRet != DD_OK)*/
                return hRet;
        }
        if (hRet != DDERR_WASSTILLDRAWING)
            return hRet;
    }
    if (hRet != DD_OK)
        return hRet;
    }
	return hRet;
}
